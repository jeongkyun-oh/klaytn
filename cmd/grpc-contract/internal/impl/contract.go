package impl

import (
	"strings"
	"sort"
	"fmt"
	"os"
	"bytes"
	"golang.org/x/tools/imports"

	"text/template"
	"ground-x/go-gxplatform/cmd/utils"
)

type Contract struct {
	Package    string
	PBPackage  string
	Name       string
	Methods    Methods
	StructName string
	Sources    Sources
}

func NewContract(pack, pbPack, name string, sources Sources) Contract {
	c := Contract{
		Package:   pack,
		PBPackage: pbPack,
		Name:      name,
		Sources:   sources,
	}
	c.StructName = strings.ToLower(string(c.Name[0])) + c.Name[1:len(c.Name)]
	return c
}

func (c *Contract) IsServerInterface(name string) bool {
	if name == c.Name+"Server" {
		return true
	}
	return false
}

var ContractTemplate string = `// Automatically generated by grpc-contract. DO NOT EDIT!
// sources: {{ range .Sources }}
//     {{ . }}
{{- end }}

package {{ .Package }};

type {{ .StructName }} struct {
	contract *{{ .Name }}
	transactOptsFn grpc.TransactOptsFn
}

func New{{ .Name }}Server(address common.Address, backend bind.ContractBackend, transactOptsFn grpc.TransactOptsFn) {{ .PBPackage | formatPackage }}{{ .Name }}Server {
	contract, _ := New{{ .Name }}(address, backend)
	service := &{{ .StructName }}{
		contract:     contract,
		transactOptsFn: transactOptsFn,
	}
	if transactOptsFn == nil {
		service.transactOptsFn = grpc.DefaultTransactOptsFn
	}
	return service
}

{{ range .Methods }}
{{ . }}
{{ end }}
`

func (c *Contract) Write(filepath, filename string) {
	sort.Sort(c.Sources)
	sort.Sort(c.Methods)
	implTemplate, err := template.New("contract").Funcs(template.FuncMap{
		"formatPackage": utils.FormatPackage,
	}).Parse(ContractTemplate)
	if err != nil {
		fmt.Printf("Failed to parse template: %v\n", err)
		os.Exit(-1)
	}
	result := new(bytes.Buffer)
	err = implTemplate.Execute(result, c)
	if err != nil {
		fmt.Printf("Failed to render template: %v\n", err)
		os.Exit(-1)
	}
	code, err := imports.Process(".", result.Bytes(), nil)
	if err != nil {
		fmt.Printf("Failed to process code: %v\n", err)
		os.Exit(-1)
	}
	utils.WriteFile(string(code), filepath, filename)
}

type Sources []string

// Len is part of sort.Interface.
func (s Sources) Len() int {
	return len(s)
}

// Swap is part of sort.Interface.
func (s Sources) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

// Less is part of sort.Interface.
func (s Sources) Less(i, j int) bool {
	return strings.Compare(s[i], s[j]) < 0
}
